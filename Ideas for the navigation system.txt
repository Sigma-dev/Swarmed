Plan A:

1 Get the triangles that make up the path, probably with an A* that uses triangle world position as a proxy for closeness
2 Lay them flat
3 Try to draw a straight line between start and target

4 If there is nothing blocking it, you have your path (maybe save every path/triangle intersection into a list and then navigate from one to the next till you reach the end)
5 If it hits a triangle side, then find which side of that side is adjacent to the next triangle and get the point that links the hit side with that side. Now repeat step 3 from that point

Now to follow the path, get the world position of that point on the current triangle we stored in step 4 and walk towards that.
We might need to add a buffer zone around the sides of meshes like navmesh do, that would reqire changing steps 3-5 by updating what counts as being "blocked" as crossing that buffer zone too.

Plan A2:

PRECOMPUTATION:

Given:
M the mesh that represents the walkable world space.

Create a Vector V that stores every Triangle in the mesh as this data structure:

center_position: Vec3
neighbors_indices: Vec<i32>



Finding the triangles:

Given:
A the starting position as a 3D position that intersects one of the mesh's triangles
B the target position as a 3D position that intersects one of the mesh's triangles

0.Initialize a "visited" vector the size of the triangles list with all negative booleans 
1.Find the triangles that contain A and B
    - Converting them to the mesh's coordinate system, then looping through every triangle until they find one that includes that position.
2.Add starting triangle to list of candidates:
3.Take the closest triangle from the sorted list of candidates.
4.If any of the neighboring triangles is the one with B in END;
5.Add the neighboring triangles that are marked as false in the visitation vector to a sorted list of all candidates, sorted by center_distance to B;
6.Set the booleans for those triangles in the visitation vector to true
7.go back to 3

